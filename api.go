package main

import (
	"context"
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/eidng8/go-admin-areas/ent"
	"github.com/eidng8/go-admin-areas/ent/schema"
)

type Server struct {
	EC *ent.Client
}

var _ StrictServerInterface = (*Server)(nil)

func newServer(entClient *ent.Client) Server {
	return Server{EC: entClient}
}

func newEngine(mode string, entClient *ent.Client) (*gin.Engine, error) {
	swagger, err := GetSwagger()
	if err != nil {
		return nil, err
	}
	swagger.Servers = nil
	switch mode {
	case gin.DebugMode:
		gin.SetMode(gin.DebugMode)
	case gin.TestMode:
		gin.SetMode(gin.TestMode)
	default:
		gin.SetMode(gin.ReleaseMode)
	}
	engine := gin.Default()
	server := newServer(entClient)
	handler := NewStrictHandler(server, []StrictMiddlewareFunc{})
	RegisterHandlersWithOptions(
		engine, handler, GinServerOptions{
			// ErrorHandler: func(ctx *gin.Context, err error, code int) {
			// // This doesn't work since the error is generated by fmt.Errorf().
			// // Such error cannot be converted to err.ValidationError.
			// 	if ent.IsValidationError(err) {
			// 		code = http.StatusUnprocessableEntity
			// 	}
			// 	ctx.JSON(code, gin.H{"error": err.Error()})
			// },
		},
	)
	return engine, nil
}

func newQueryContext(withTrashed *bool, ctx context.Context) context.Context {
	var qc context.Context
	if nil == ctx {
		qc = context.Background()
	} else {
		qc = ctx
	}
	if nil != withTrashed && *withTrashed {
		qc = schema.IncludeTrashed(qc)
	}
	return qc
}

func handleErrorResponse(ctx *gin.Context, err error) {
	_ = ctx.Error(err)
	switch {
	case ent.IsValidationError(err):
		ctx.Status(http.StatusUnprocessableEntity)
	case ent.IsNotFound(err):
		ctx.Status(http.StatusNotFound)
	default:
		ctx.Status(http.StatusInternalServerError)
	}
}
